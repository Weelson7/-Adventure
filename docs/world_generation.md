# World Generation

## Overview
Procedural creation of the game world, including tectonic plates, elevation, temperature, water bodies, and regional features.

## Core Concepts
- Tectonic plate simulation based on world size
- Elevation and temperature determined by latitude, elevation, and proximity to water
- Lakes generated at random locations; rivers flow from mountains to seas
- Regional features include volcanoes, magic zones, submerged cities
- Checks to prevent illogical features (e.g., no lake in an ocean)

## Data Structures & Relationships
- WorldGrid: 3D grid of tiles
- Plate: Represents tectonic plates
- Tile: Contains elevation, temperature, biome, features
- RegionalFeature: Volcanos, magic zones, etc.

## Generation & Initialization
- Number of plates determined by world size
- Elevation generated by plate movement
- Temperature calculated from latitude/elevation
- Water bodies and regional features placed with logic checks

## Interactions & Edge Cases
- Biome assignment based on tile attributes
- Rivers/lakes must not overlap oceans
- Rare features distributed regionally
- Edge cases: isolated plates, microplates, abrupt transitions

## Expansion & Modularity
- Add new regional features (e.g., magical anomalies)
- Modular biome/resource system

## Open Questions

This file should be considered in-sync with `docs/TO_FIX.md` and `docs/open_questions.md` (canonical tracker).

- Plate physics level: cellular automata-style heightmap rules or per-plate drift vectors with iterative boundary rules? (impacts performance and debugability).
- River algorithm tuning: values for sourceElevationThreshold, minimum catchment area, maximum path length, plateau tie-break noise amplitude.
- Simplified vs deep simulation: which per-tile fields are aggregated or discarded in background updates (e.g., NPC counts, transient event queues, temporary buffs)?
- Chunking & persistence: ideal chunk size (default 64x64) and compression strategy for large-world performance.
- Deterministic coverage: ensure plate placement, river carving, and regional feature seeding use the same RNG seed flow â€“ identify any subsystems that currently use non-seeded randomness.
- Debug visualization needs: which intermediate maps (plate boundaries, uplift areas, river catchments) must be output by debug mode for debugging and testing.

For unresolved or cross-cutting questions, add entries to `docs/open_questions.md` and `docs/TO_FIX.md` so they can be triaged and prioritized.

## Algorithmic Breakdown
- **Tectonic Plate Simulation:**
    1. Initialize plates based on world size and seed.
    2. Assign movement vectors and collision rules.
    3. Simulate plate movement, collision, and subduction to generate elevation map.
- **Elevation & Temperature:**
    1. Calculate elevation from plate interactions.
    2. Assign temperature using latitude, elevation, and proximity to water.
- **Water Bodies:**
    1. Place lakes in low elevation, non-ocean tiles.
    2. Generate rivers from mountain sources, following lowest elevation path to sea.
- **Regional Features:**
    1. Place rare features (volcanoes, magic zones) using weighted random distribution and logic checks.
    2. Validate feature placement to avoid illogical overlaps.

## Simulation Model (concrete guidance)

This project uses a deterministic, tick-driven simulation for world generation and ongoing regional simulation.

- Tick length: configurable; recommended default = 1 real-time second per tick for server-side simulation, with the ability to fast-forward during offline generation.
- Determinism: all procedural steps take an explicit seed. Systems that require randomness must accept a seeded RNG instance so generation is reproducible.
- Active vs simplified regions: regions within an activity radius (player proximity or forced activation) run a deep simulation every tick. Distant regions run a simplified update every N ticks (recommend 60x slower by default). Documented fields:
	- activeTickRateMultiplier = 1 (full speed)
	- backgroundTickRateMultiplier = 1/60
	- lastFullSimTick stored per region
- Upgrade/downgrade rules: when a region becomes active, run a deterministic resynchronization step to apply aggregated background changes (event queue replay or summarized deltas) to avoid desync.
- State persistence: record lastProcessedTick per region and persist delta events for migration.

## River & Pathfinding Algorithm

Chosen approach: priority-queue downhill flow (Dijkstra-like) that treats elevation as cost. Rationale: deterministic, handles plateaus and basins, and produces stable results.

- Algorithm outline:
	1. Identify river sources: tiles above sourceElevationThreshold with sufficient upstream catchment area.
	2. For each source, run a best-first search using a priority queue ordered by elevation (lowest next). Expand to neighbors and prefer neighbors with strictly lower elevation; allow equal-elevation moves but with a small added penalty to encourage downhill flow.
	3. Terminate when reaching an ocean tile, joining an existing river, or exceeding a maximum path length.
	4. Post-processing: smooth river path, carve banks lowering adjacent tile elevations slightly, and validate no uphill segments.

- Edge cases: plateaus resolved via tiny deterministic noise (seeded) to break ties; closed basins may become lakes if no path to ocean is found.

**Complexity & Performance:**
- Time complexity: O(T log T) where T = number of tiles in catchment area (priority queue operations).
- Typical rivers cover <1% of map tiles, so practical runtime is fast even for large worlds.
- Optimization: cache elevation lookups and precompute neighbors for grid traversal.

**Edge Case Handling:**
- **Plateaus**: add seeded micro-noise (amplitude < 0.01) to elevation to create deterministic downhill preference.
- **Closed basins**: if river cannot reach ocean within maxPathLength, terminate and mark start tile as lake source.
- **Existing river collision**: when river joins existing river, merge flows and update river network graph for hydrology (optional advanced feature).

## Plate Simulation Approach

Recommendation: Voronoi partitioning for initial plate regions plus per-plate vector drift simulation (cell ownership + movement vector). Use iterative collision/subduction rules rather than full physics for performance and explainability.

- Steps:
	1. Seed plate centers using world size and plateCount.
	2. Generate Voronoi regions to assign tiles to plates.
	3. Assign each plate a movement vector and convergence type.
	4. Run N simulation steps applying boundary collisions to change elevation: convergence -> mountain uplift, divergence -> rift lowering, transform -> lateral shear.

**Complexity & Performance:**
- Voronoi generation: O(T log P) using Fortune's algorithm or relaxed Lloyd's iterations, where T = tile count, P = plate count.
- Collision simulation: O(N * B) where N = simulation steps (default 50-100), B = boundary tile count (typically <10% of T).
- Overall: linear in tile count for realistic plate counts (<20 plates).

**Edge Case Handling:**
- **Microplates**: plates with <100 tiles are merged into neighboring plates during initialization to avoid simulation instability.
- **Isolated plates**: plates with no neighbors (rare) are flagged and assigned neutral convergence (no uplift/subduction).
- **Abrupt transitions**: smooth elevation boundaries post-simulation using Gaussian blur or iterative averaging (radius=3 tiles).

Notes: document expected complexity and provide debug visualizations for plate boundaries and uplift areas in debug mode.

## Parameterization
- World size (width, height, altitude layers)
- Plate count and size variability
- Biome types and rarity
- Feature rarity and distribution weights
- Resource abundance and hazard frequency
- Seed for reproducibility

## Validation & Debugging
- Automated checks for illogical features (e.g., lakes in oceans, rivers flowing uphill)
- Debug mode to visualize plate boundaries, elevation, and feature placement
- Logging of generation steps and anomalies

## Performance & Scalability
- Use batched/staggered updates for distant regions
- Optimize grid traversal and pathfinding for rivers
- Parallelize plate simulation and feature placement for large worlds
- Adjustable simulation depth based on player proximity

## Persistence & Serialization
- Save/load generated worlds using versioned data formats
- Support for world migration and upgrades
- Store seed and generation parameters for reproducibility

## Modding & Extensibility
- Modular biome and feature system: allow new biomes/features via config files or plugins
- Expose generation parameters and hooks for modders
- Document extension points for custom world logic

## Visual Representation
- Map rendering of world grid, biomes, elevation, and features
- Color coding for temperature, altitude, and water bodies
- Overlay for plate boundaries and regional features in debug mode

## Testing & Quality Assurance
- Automated tests for generation logic (plate movement, river pathfinding, feature placement)
- Seed management for reproducible worlds
- Regression tests for edge cases and illogical outcomes

## Error Handling
- Fallback logic for failed generation steps (e.g., retry river placement)
- Warnings for invalid configurations
- Graceful degradation for missing or corrupt data

## Integration Points
- Hooks for societies, structures, and events to interact with world features
- APIs for querying tile attributes, biomes, and regional features
- Event triggers for world changes (e.g., volcanic eruption starts story)

## Accessibility & Customization
- User-facing options for world size, biome frequency, and feature density
- Accessibility settings for colorblind-friendly map rendering
- Custom presets for world generation parameters

## Design Decisions

For canonical design decisions, see **`docs/design_decisions.md`**. Key decisions relevant to world generation:

- Determinism: all procedural generation uses explicit seeds.
- Active vs simplified regions: tick-rate multipliers determine update frequency.
- Biomes do not directly affect character stats (except via explicit features like magic zones).
- Resource abundance balanced by biome rarity, altitude, and dynamic regeneration.
- Rare features have unique gameplay effects and may trigger events.

Refer to `docs/design_decisions.md` for the full authoritative list and cross-cutting decisions.
